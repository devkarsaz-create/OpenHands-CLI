"""Trajectory loading and management for E2E testing.

This module provides utilities for loading and parsing agent trajectories
from JSON files. Trajectories are used by the mock LLM server to replay
deterministic agent responses for e2e testing.

A trajectory is a sequence of events stored as individual JSON files:
- MessageEvent (source=user): User input - sent by e2e test as simulated input
- ActionEvent (source=agent): Agent tool calls - replayed by mock LLM server
- ObservationEvent (source=environment): Tool results - generated by actual execution
- MessageEvent (source=agent): Agent text responses - replayed by mock LLM server

The mock LLM server only needs to replay:
1. ActionEvents with tool_call data (converted to OpenAI tool_calls format)
2. MessageEvents from agent (converted to OpenAI assistant messages)
"""

import json
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Literal


@dataclass
class TrajectoryEvent:
    """A single event in a trajectory."""

    id: str
    timestamp: str
    source: Literal["user", "agent", "environment"]
    kind: str
    raw_data: dict[str, Any]

    # For ActionEvent with tool calls
    tool_call: dict[str, Any] | None = None
    tool_name: str | None = None
    tool_call_id: str | None = None
    reasoning_content: str | None = None
    thinking_blocks: list[dict[str, Any]] = field(default_factory=list)

    # For MessageEvent
    llm_message: dict[str, Any] | None = None

    @classmethod
    def from_json(cls, data: dict[str, Any]) -> "TrajectoryEvent":
        """Parse a trajectory event from JSON data."""
        return cls(
            id=data.get("id", ""),
            timestamp=data.get("timestamp", ""),
            source=data.get("source", "user"),
            kind=data.get("kind", ""),
            raw_data=data,
            tool_call=data.get("tool_call"),
            tool_name=data.get("tool_name"),
            tool_call_id=data.get("tool_call_id"),
            reasoning_content=data.get("reasoning_content"),
            thinking_blocks=data.get("thinking_blocks", []),
            llm_message=data.get("llm_message"),
        )

    def is_user_input(self) -> bool:
        """Check if this event represents user input to be simulated."""
        return self.source == "user" and self.kind == "MessageEvent"

    def is_llm_response(self) -> bool:
        """Check if this event should be replayed by the mock LLM server."""
        return self.source == "agent" and self.kind in ("ActionEvent", "MessageEvent")

    def get_user_text(self) -> str:
        """Extract user input text from a MessageEvent."""
        if not self.llm_message:
            return ""
        content = self.llm_message.get("content", [])
        if isinstance(content, str):
            return content
        if isinstance(content, list):
            for item in content:
                if isinstance(item, dict) and item.get("type") == "text":
                    return item.get("text", "")
        return ""


@dataclass
class Trajectory:
    """A complete agent trajectory for e2e testing."""

    name: str
    path: Path
    events: list[TrajectoryEvent]

    def get_user_inputs(self) -> list[TrajectoryEvent]:
        """Get all user input events that the e2e test should send."""
        return [e for e in self.events if e.is_user_input()]

    def get_llm_responses(self) -> list[TrajectoryEvent]:
        """Get all events that should be replayed by the mock LLM server."""
        return [e for e in self.events if e.is_llm_response()]


def load_trajectory(trajectory_path: Path | str) -> Trajectory:
    """Load a trajectory from a directory of event JSON files.

    Args:
        trajectory_path: Path to directory containing event-XXXXX-*.json files

    Returns:
        Trajectory object with parsed events
    """
    path = Path(trajectory_path)
    if not path.is_dir():
        raise ValueError(f"Trajectory path must be a directory: {path}")

    # Find all event files and sort by sequence number
    event_files = sorted(path.glob("event-*.json"))
    if not event_files:
        raise ValueError(f"No event files found in {path}")

    events = []
    for event_file in event_files:
        with open(event_file) as f:
            data = json.load(f)
            event = TrajectoryEvent.from_json(data)
            events.append(event)

    return Trajectory(
        name=path.name,
        path=path,
        events=events,
    )


def get_trajectories_dir() -> Path:
    """Get the default trajectories directory."""
    return Path(__file__).parent.parent / "tests" / "trajectories"


def list_available_trajectories() -> list[str]:
    """List all available trajectory names."""
    trajectories_dir = get_trajectories_dir()
    if not trajectories_dir.exists():
        return []
    return [d.name for d in trajectories_dir.iterdir() if d.is_dir()]
